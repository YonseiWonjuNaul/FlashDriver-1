3.28(수) BM 관련.
1. inline 함수를 .h에 안넣고 .c에 넣어서 linking error 나던 것 수정.
2. v_PBA와 o_PBA를 setting하는 함수 추가. (PE_cycle의 wear-leveling과 Bad Block임을 고려하여서 만들어짐)

3. FTL은 wear-leveling(PE_cycle)과 Bad block 문제가 전혀 없는 깨끗하고 순수한 block들을 봐야 한다. 그래서 FTL과 실제 blockArray의 PBA와는 하나의 layer가 존재해야 한다. 따라서 FTL에서 특정 PBA에 접근하고자 한다면, 그건 BM_FTLPBA 함수를 거쳐서 그에 대응되는 '진짜 Flash의 Physical PBA' 로 변환되어야 한다. 당연히 반대도 되어야 하고. 
	FTL이 Flash 안의 데이터에 접근하고자 할 때, BM_FTLtoFLASH(PBA)를 거쳐서 넣어야 한다.

4. v_PBA를 알 때 그걸 가지고 그와 같은 block structure에 들어있는 PBA값을 찾아낼 수 있는 함수 추가.
	FTL이 Flash로부터 데이터를 가져오고 싶을 때 사용해야 함.


v_PBA는 이름은 v_PBA인데 사실 이게 '진짜로 Flash에 물리적으로 접근되는 Block의 PBA' 이다. 주의하기.. 이름을 바꿔야 하나?

[예시]
	<위>
FTL이 보는 깨끗한 PBA: 0 1 2 3 4 ...
사실 처리 이후의 PBA : 2 0 4 3 ....
	<아래>

만약 FTL이 2번 block에 값을 넣으려고 한다면, 사실 2번이 아니라 virtual layer를 거쳐서 4번 block에 넣어야 한다. 물론 FTL은 그게 2번이라고 믿고 있다.
그리고 FTL이 2번(이라고 믿고 있는) block에서 값을 꺼내려고 한다면, 사실 2번이 아니라 virtual layer를 거쳐서 4번 block의 값을 꺼내게 된다.
	이 때는 BM_FTLtoFLASH()
	즉, 위에서 아래로 보는 것.

그런데 만약 FTL이 '진짜로 Flash의 4번 block' 에 대응되는 깨끗한 PBA를 역으로 보려고 한다면
	이 때는 BM_FLASHtoFTL()
	즉, 아래에서 위로 보는 것.
	근데 이건 FTL이 쓸 일은 없을 것 같다.

5. BM_Minheap_numValid의 처음 부분에 BADBLOCK 검사 여부 추가
	BADBLOCK인 경우, numValid를 0으로 초기화한다. 따라서 그냥 Minheap에 넣으면 BADBLOCK이 root가 되어버리는 문제가 발생할 것이다.
	따라서, Minheap의 경우에는 BADBLOCK의 numValid를 255(0xff)로 설정하여 leaf node에 오도록 바꾼다. 
	(그렇지만, 여기서 n번만큼 추가 연산이 발생하는 것에 대해서는 문제의 여지가 있어 보인다)

6. 각종 버그 수정
- numValid는 0~256의 값을 가져야 하는데, uint8_t로 선언되어 있어서 0~255밖에 담지 못하여 계속 overflow가 나는 상황이었음(256->0이 됨)
- block pointer로부터 다른 멤버변수에 접근하기 위한 방법으로 계속 멤버변수들의 크기만큼 더해주어서 포인터를 계산했는데, 그 방법은 BAD까지는 찾을 수 있었으나 그 다음의 v_PBA와 o_PBA는 찾을 수 없었음(이상한 값이 들어감). 그냥 (Block*)ptr_block에서 ->로 멤버변수를 바로 참조하는 방법을 사용했더니 오류 없이 찾을 수 있었음.
